# 手动实现

1. call

> `call方法`使用一个指定的this和单独给出的一个或多个参数来调用一个函数。
`call`原理比较简单，函数的`this`指向它的直接调用者，变更调用者即完成this指向变更
```js
// 变更函数调用者示例
function getName() {
  console.log(this.name)
}
let name = 'react'
let obj = {
  name: 'vue'
}

obj.getName = getName
obj.getName()   // 'vue'
```
基于以上原理，实现基础`call()`
```js
Function.prototype.myCall = function(thisArg, ...argArr) {
  thisArg.fn = this   // this指向调用call的对象(thisArg)
  return thisArg.fn(...argArr)  // 执行函数并返回执行结果
}
```
处理一些细节：
```js
Function.prototoype.myCall = function(thisArg, ...argArr) {
  if(typeof this !== 'function') {
    throw new Error('must be a function')
  }
  let fn = Symbol('fn')     // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
  thisArg = thisArg || window   // 若没有传入this，默认绑定window
  thisArg[fn] = this  // this指向调用call的对象,即我们要改变this指向的函数
  const result = thisArg[fn](...argArr) // 执行当前函数
  delete thisArg[fn]  // 删除声明的fn属性
  return result   // 返回函数执行的结果
}
```

2. apply
> `apply()` 方法调用一个具有给定`this`值的函数，以及作为一个数组（或类似数组对象）提供的参数
`apply()`和`call()`类似，区别在于`call()`接收参数列表，而`apply()`接收一个参数数组
```js
Function.prototype.myApply = function(thisArg, args) {
  if(typeof this !== 'function') {
    throw new Error('must be a function')
  }

  let fn = Symbol('fn')  // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
  thisArg = thisArg || window  // 没有传入this，默认绑定window

  thisArg[fn] = this    // this指向调用call的对象,即我们要改变this指向的函数
  const result = thisArg[fn](args ? ...args : args) // 执行当前函数
  delete thisArg[fn]    // 删除声明的fn函数
  return result   // 返回函数执行结果
}
```

3. bind
> bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
从用法上看，似乎给call/apply包一层function就实现了bind()
```js
Function.prototype.myBind = function(thisArg, ...args) {
  return () => {
    this.apply(thisArg, args)
  }
}
```
**TODO: 待优化 **

4. 防抖
防抖常用于搜索框/滚动条的监听，如果不做防抖，没输入一个字或滚动，都会触发事件处理，造成性能浪费
```js
function debounce(fn, time = 2000) {
  let timer 
  return function(...args) {
    const context = this
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
        fn.apply(context, args)
        timer = null
    }, time)
  }
}
```
5. 节流
```js
function throttle(fn, time = 200) {
  let timer = null
  return function(...args) {
    const context = this
    if(!timer) {
      timer = setTimeout(() => {
        fn.apply(context, atgs)
        timer = null
      }, time)
    }
  }
}
```

6. 数组扁平化
- Array.prototype.flat
```js
const arr = [1, [2, [3, 4]]]
arr.flat(Infinity)
```
- 迭代 + 展开运算符
```js
let arr =  [1, [2, [3, 4]]]
while(arr.some(Array.isArray)) {
  arr = [].concat(...arr)
}

console.log(arr)
```
- 递归
```js
function flat(arr) {
  let res = []
  for(let item of arr) {
     Array.isArray(item) ? res = res.concat(flat(item)) : res.push(item)
  }
  return res
}
```
- reduce递归
```js
function flat(arr) {
  return arr.reduce((acc, cur) => acc.concat(Array.isArray(cur) ? flat(cur) : cur), [])
}
```

7. 实现Promise
```js

function Promise(fn) {
  const that = this
  this.state = 'pending'
  this.value = null
  this.resolvedCallbacks = []
  this.rejectedCallbacks = []

  function resolve(val) {
    if(that.state === 'pending') {
      that.state = 'fulfilled'
      that.value = val
      that
    }
  }

  function reject() {

  }
 
  try {

  } catch {

  }
}
```