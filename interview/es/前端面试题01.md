# 前端面试题

1. `call`和`apply`异同点，哪个性能更好
- 相同点：
都是函数原型上的方法；都可以改变函数`this`指向
- 不同点
传递给函数参数方式不一样，`call(obj, arg1, arg2, arg3, ...)`传递给函数参数为一个个数值；`apply(obj, [arg1, arg2, arg3, arg4, ...])`传递给函数参数为一个数组。

`call`比`apply`性能要好一些(*尤其是传参`>3`时*)

2. 实现`(3).add(5).minus(2)`输出结果为`6`.

<<< @/interview/codes/code01.js#snippet1


3. 把一个字符串的大小写取反，如`AbC`变成`aBc`

- 解法一：通过`charCodeAt`判断`ASCII`值是否大于等于`97`(*`a为97;A问65`*)

<<< @/interview/codes/code01.js#snippet2

- 解法二: 

<<< @/interview/codes/code01.js#snippet3

- 解法三：利用正则匹配字母, **推荐，上面方法没考虑边界问题**
```js
function revertStr(str) { // content：第一次正则匹配的结果
  return str.replace(/[a-zA-Z]/g, content => content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase())
}
```
4. 箭头函数和普通函数区别？普通函数可以通过`new`实例化，箭头函数呢，为什么？
**箭头函数**和普通函数区别
- 箭头函数语法比普通函数更简洁
- `this`指向，箭头函数没有自己`this`，它的`this`指向箭头函数所处上下文(无法使用`call`和`apply`改变this指向)
```js
document.body.onclick = () => {
  // this -> window
}
document.body.onclick = function() {
  // this -> body
  [1, 2, 3].sort(function(a, b) {  // 普通回调函数的this一般指向window
    // this -> window
    return a - b  // 升序
  })
  [10, 20, 30].sort((a, b) => {
    // this -> body
    return b - a  // 降序
  })
}
```
- 箭头函数没有`arguments`(类数组)对象，可以通过展开运算符(`...args`)来获取
- 箭头函数不能被实例化(`new`操作符实例化)，箭头函数没有`this`,也**没有`prototype`属性**
<!-- each方法 -->
<!-- 重写replace方法 -->

5. 实现字符串(`String`)的`indexOf`方法
```js
+function() {
  function myIndexOf(flag) {
    const reg = new RegExp(flag)
    const res = reg.exec(this)
    return res === null ? -1 : res.index
  }
  String.prototype.myIndexOf = myIndexOf
}()
```

6. 写出输出值
```js
// 1.
var a = {}, b = '123', c = 123;
a[b] = 'b'
a[c] = 'c'
console.log(a[b])  // 'c'  a['123'] === a[123]

// 2.
var a = {}, b = Symbol('123'), c = Symbol(''123)
a[b] = 'b'
a[c] = 'c'
console.log(a[b]) // 'b' Symbol创建唯一标识符, Symbol('123') != Symbol('123')

// 3.
var a = {}, b = {key: 123}, c = {key: 456}
a[b] = 'b'
a[c] = 'c'
console.log(a[b]) // 'c'
// 对象的属性名不能是对象，如果遇到对象属性名，会默认转为字符串
// obj = {}; arr = [1, 2]; obj[arr] = 'vue'; obj = {'12': 'vue'}
// 普通对象.toString方法，调用的是Object.prototype原型上的方法
// obj = {}; obj.toString() => "[object Object]"
```

7. 网站正则
条件：
- 
```
```

8. 一下输出什么
```js
function Foo() {
  Foo.a = function() {
    console.log(1)
  }
  this.a = function() {
    console.log(2)
  }
}
Foo.prototype.a = function() {
  console.log(3)
}
Foo.a = function() {
  console.log(4)
}

Foo.a()   // log: 4
const foo = new Foo() // 实例化时，会执行Foo函数
foo.a()  // log: 2
Foo.a()  // log: 1
```

9. 图片懒加载实现
10. 