# JavaScript变量提升和函数提升

`JS`引擎在正式执行之前会先进行一次编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。

## 变量提升
1. `JS`引擎会将变量提升至函数顶部，初始值为`undefined`
```js
var foo = 3
function hoistVariable() {
  console.log(foo)
  var foo = foo || 5

  console.log(foo)
}
hoistVariable()
console.log(foo)
// log: undefined 5 3
```
预编译后的代码逻辑：
```js
// 预编译之后
var foo = 3
function hoistVariable() {
  var foo
  console.log(foo)
  foo = foo || 5

  console.log(foo)
}
console.log(foo)
```
2. 如果当前作用域中声明多个同名变量，那么他们的同一个标识符会被提升至作用域顶部，其他部分按顺序执行。
```js
function hoistVariable() {
  var foo = 3
  {
    var foo = 5
  }
  console.log(foo)  
}

hoistVariable() // log: 5
```
因为`ES6`之前没有块级作用域，只有全局作用域和函数作用域，所有预编译之后的代码逻辑：
```js
// 预编译之后
function hoistVariable() {
  var foo
  foo = 3
  {
    foo = 5
  }
  console.log(foo)
}
hoistVariable() // log: 5
```

## 函数提升

1. 函数在声明之前就可以调用，并且跟变量声明不同的是，它还能直接正确执行，其实是因为`JS`引擎把函数声明整个地提升到了当前作用域的顶部

2. 如果在同一个作用域中存在多个同名函数声明，后面的会覆盖前面的函数声明
```js
function hoistFunction() {
  function foo() {
    console.log(1)
  }
  foo()
  function foo()
  console.log(2)
}
hoistFunction() // log: 2
```

3. 函数声明和函数表达式执行顺序

## 示例
```js
console.log('1:', foo)
var foo = 'javascript'

console.log('2', foo)

function foo() {
  console.log('function')
}

console.log('3', foo)
/** log:
 *  1: function foo() {}
 *  2: javascript
 *  3: javascript
 */
```
预编译后的代码逻辑:
```js
var foo
function foo() {
  console.log(function)
}
console.log(1, foo)

foo = 'javascript'

console.log(2, foo)
console.log(3, foo)
```

## 参考
1. [JavaScript: 变量提升和函数提升](https://www.cnblogs.com/liuhe688/p/5891273.html)